##  <center> 实验报告</center>
### <center>小组成员</center>
张涛丹 2212009        
申展2211321        
克梦宇2211765
## 一.练习 1：理解 first-fit 连续物理内存分配算法
### (1)最先匹配法(first-fit)的基本原理
内存分配器维护一个空闲块的列表（称为空闲列表），当收到内存请求时，会扫描列表以找到第一个足够大的块来满足请求。如果选中的块远大于请求的大小，通常会将其拆分，剩余部分作为另一个空闲块加入列表。这个算法的优点在于分配和释放的时间性能较好，较大的空闲分区可以被保留在内存高端，但随着低端分区不断划分而产生较多小分区，每次分配时查找时间开销会增大。

考虑first-fit算法目前存在的缺点，从而考虑可能存在的改进空间：由于每次进行内存分配时，都需要从空闲链表中查找第一个满足大小要求的块。这种线性查找的时间复杂度为 O(n)（n代表链表中空闲块的数量）。随着系统运行时间的增长，空闲块的数量会不断增多，产生越来越多的小分区导致每次分配内存的速度变得越来越慢。
    
可能的改进方法：其中一个可能的解决方案类似于best-fit算法中针对空闲块排序的方法，考虑把空闲块存储在一个堆里，按照内存块大小进行排序。每次请求内存时，从堆顶元素向下依次比较，这样就能在O(logn)级别的复杂度下快速找到最合适的内存块。这样做的优点是虽然依旧会形成较多空闲块，但它们的规模都较小，较大的空闲分区可以被保留。如果想要消除小的空闲分区，可以采用类似于worst-fit算法的逻辑，但这样会使得最大的那些空闲分区不被保留，会很容易出现存入较大的数据时物理内存不足的情况，此时就需要内存管理技术介入了。

一个比较折中的方案是使用类似于Linux中Buddy System的方式，内存分配器可以通过伙伴算法高效合并相邻的空闲块，将内存分成固定大小的2的幂次方块，并以BST管理，使分配和回收更加高效，从而尽可能实现最佳的策略。


### (2)相关函数的作用：

1. default_init()：用于初始化内存管理结构体
    
    调用 list_init(&free_list) 初始化空闲列表。设置了nr_free = 0，表示开始时没有空闲页块。
    
    这个函数在系统启动时调用，一次性初始化物理内存管理器。
   
3. default_init_memmap：用于初始化一段物理内存块，添加到空闲链表中。
    
    循环遍历从 base 开始的 n 个页块，设置页块的 flags 和 property=0，并设置引用计数 ref 为 0。
    
    标记第一页块属性，将 base->property 设置为 n，表示这段内存包含 n 个页，并将首块base的 PG_property 设置为有效。将当前free页面+n更新。
    
    将初始化的内存块添加到空闲链表中，如果空闲列表为空，直接插入到 free_list 中。如果不为空，则遍历链表找到合适的位置（找到base 的物理地址<page 的物理地址，然后base前插，保证地址由低到高）。
    
   在系统启动时，内核需要知道哪些物理页面是可用的，default_init_memmap函数被用于初始化这些可用页面，并将其添加到空闲链表 free_list 中
4. default_alloc_pages：内存分配函数，使用 First-Fit 策略在空闲列表中查找一个足够大的块。
   当收到内存请求时，会遍历空闲列表以找到第一个足够大的块（页数大于等于 n）来满足请求，如果找到就将其指针存储到page中。然后将page从空闲列表中删除，如果page的大小大于请求n的大小，将剩余的部分作为另一个空闲块加入空闲列表。

5. default_free_pages：内存释放函数，用于释放占用的页块，并将其加入到空闲列表中，同时合并相邻的空闲块。
    
    遍历释放的页块，清除其 flags 和引用计数，并设置页的 property=0。
    
    按地址顺序将新的页块插入空闲列表，以保持链表的有序性。
    
    在插入后，检查 base 的前一个和后一个页块，如果它们也是空闲的，将其与 base 合并，并更新合并后的页块属性。

这五个函数实现了first-fit算法的基本流程。

## 练习2：实现 Best-Fit 连续物理内存分配算法（需要编程）
在完成练习一后，参考kern/mm/default_pmm.c对First Fit算法的实现，编程实现Best Fit页面分配算法，算法的时空复杂度不做要求，能通过测试即可。
请在实验报告中简要说明你的设计实现过程，阐述代码是如何对物理内存进行分配和释放，并回答如下问题：
- 你的 Best-Fit 算法是否有进一步的改进空间？

## 扩展练习Challenge：buddy system（伙伴系统）分配算法（需要编程）

Buddy System算法把系统中的可用存储空间划分为存储块(Block)来进行管理, 每个存储块的大小必须是2的n次幂(Pow(2, n)), 即1, 2, 4, 8, 16, 32, 64, 128...

 -  参考[伙伴分配器的一个极简实现](http://coolshell.cn/articles/10427.html)， 在ucore中实现buddy system分配算法，要求有比较充分的测试用例说明实现的正确性，需要有设计文档。
 
## 扩展练习Challenge：任意大小的内存单元slub分配算法（需要编程）

slub算法，实现两层架构的高效内存单元分配，第一层是基于页大小的内存分配，第二层是在第一层基础上实现基于任意大小的内存分配。可简化实现，能够体现其主体思想即可。

 - 参考[linux的slub分配算法/](http://www.ibm.com/developerworks/cn/linux/l-cn-slub/)，在ucore中实现slub分配算法。要求有比较充分的测试用例说明实现的正确性，需要有设计文档。

## 扩展练习Challenge：硬件的可用物理内存范围的获取方法（思考题）
  - 如果 OS 无法提前知道当前硬件的可用物理内存范围，请问你有何办法让 OS 获取可用物理内存范围？


> Challenges是选做，完成Challenge的同学可单独提交Challenge。完成得好的同学可获得最终考试成绩的加分。
