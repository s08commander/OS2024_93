##  <center> 实验报告</center>
### <center>小组成员</center>
张涛丹 2212009        
申展2211321        
克梦宇2211765
## 一.练习 1：理解 first-fit 连续物理内存分配算法
### (1)最先匹配法(first-fit)的基本原理
内存分配器维护一个空闲块的列表（称为空闲列表），当收到内存请求时，会扫描列表以找到第一个足够大的块来满足请求。如果选中的块远大于请求的大小，通常会将其拆分，剩余部分作为另一个空闲块加入列表。这个算法的优点在于分配和释放的时间性能较好，较大的空闲分区可以被保留在内存高端，但随着低端分区不断划分而产生较多小分区，每次分配时查找时间开销会增大。

考虑first-fit算法目前存在的缺点，从而考虑可能存在的改进空间：由于每次进行内存分配时，都需要从空闲链表中查找第一个满足大小要求的块。这种线性查找的时间复杂度为 O(n)（n代表链表中空闲块的数量）。随着系统运行时间的增长，空闲块的数量会不断增多，产生越来越多的小分区导致每次分配内存的速度变得越来越慢。
    
可能的改进方法：其中一个可能的解决方案类似于best-fit算法中针对空闲块排序的方法，考虑把空闲块存储在一个堆里，按照内存块大小进行排序。每次请求内存时，从堆顶元素向下依次比较，这样就能在O(logn)级别的复杂度下快速找到最合适的内存块。这样做的优点是虽然依旧会形成较多空闲块，但它们的规模都较小，较大的空闲分区可以被保留。如果想要消除小的空闲分区，可以采用类似于worst-fit算法的逻辑，但这样会使得最大的那些空闲分区不被保留，会很容易出现存入较大的数据时物理内存不足的情况，此时就需要内存管理技术介入了。

一个比较折中的方案是使用类似于Linux中Buddy System的方式，内存分配器可以通过伙伴算法高效合并相邻的空闲块，将内存分成固定大小的2的幂次方块，并以BST管理，使分配和回收更加高效，从而尽可能实现最佳的策略。


### (2)相关函数的作用：

1. default_init()：用于初始化内存管理结构体
    
    调用 list_init(&free_list) 初始化空闲列表。设置了nr_free = 0，表示开始时没有空闲页块。
    
    这个函数在系统启动时调用，一次性初始化物理内存管理器。
   
3. default_init_memmap：用于初始化一段物理内存块，添加到空闲链表中。
    
    循环遍历从 base 开始的 n 个页块，设置页块的 flags 和 property=0，并设置引用计数 ref 为 0。
    
    标记第一页块属性，将 base->property 设置为 n，表示这段内存包含 n 个页，并将首块base的 PG_property 设置为有效。将当前free页面+n更新。
    
    将初始化的内存块添加到空闲链表中，如果空闲列表为空，直接插入到 free_list 中。如果不为空，则遍历链表找到合适的位置（找到base 的物理地址<page 的物理地址，然后base前插，保证地址由低到高）。
    
   在系统启动时，内核需要知道哪些物理页面是可用的，default_init_memmap函数被用于初始化这些可用页面，并将其添加到空闲链表 free_list 中
4. default_alloc_pages：内存分配函数，使用 First-Fit 策略在空闲列表中查找一个足够大的块。
   当收到内存请求时，会遍历空闲列表以找到第一个足够大的块（页数大于等于 n）来满足请求，如果找到就将其指针存储到page中。然后将page从空闲列表中删除，如果page的大小大于请求n的大小，将剩余的部分作为另一个空闲块加入空闲列表。

5. default_free_pages：内存释放函数，用于释放占用的页块，并将其加入到空闲列表中，同时合并相邻的空闲块。
    
    遍历释放的页块，清除其 flags 和引用计数，并设置页的 property=0。
    
    按地址顺序将新的页块插入空闲列表，以保持链表的有序性。
    
    在插入后，检查 base 的前一个和后一个页块，如果它们也是空闲的，将其与 base 合并，并更新合并后的页块属性。

这五个函数实现了first-fit算法的基本流程。

## 练习2：实现 Best-Fit 连续物理内存分配算法（需要编程）
### 链表初始化best_fit_init_memmap() ###

遍历从 base 开始的 n 个页块，将每个页的 flags 和 property 清零，并将引用计数置为 0。
将整个 base 页块设置为一个连续的空闲区域，其大小为 n 页。
更新空闲页数 nr_free。
遍历 free_list，根据地址大小将 base 按升序插入到空闲链表中（保持链表有序）。

### 分配页best_fit_alloc_pages() ###

遍历 free_list 找到最小合适的页块（p->property >= n 且 p->property 最小）。

如果找到合适的页块：从链表中移除该页块。

如果页块比需求大，将剩余部分拆分为一个新的空闲块，并插入链表。更新空闲页数 nr_free，清除分配的页块的属性标记。

如果没有找到合适的页块，返回 NULL。

### 释放页best_fit_free_pages() ###

遍历释放的页块，将其属性（property）和标记清零。
设置 base 页块的大小为 n 页，标记为空闲，并插入到 free_list 的正确位置。

检查链表中前后相邻的页块：

如果前一个页块与当前页块连续（p + p->property == base），将其合并。

如果后一个页块与当前页块连续（base + base->property == p），将其合并。

## 扩展练习Challenge：硬件的可用物理内存范围的获取方法（思考题）
 1.通过设备树（Device Tree, DTB）。QEMU 在启动时会向操作系统传递一个设备树（DTB 文件）
 
 2.OpenSBI通常会提供内存布局信息，例如通过 struct sbi_scratch 或其他引导数据结构传递。
